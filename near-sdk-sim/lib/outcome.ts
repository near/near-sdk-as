import { RustRef, UTF8toStr } from "./utils";
import * as sim from "../native.node";

/**
 * An ExecutionResult is created by a UserAccount submitting a transaction.
 * It wraps an ExecutionOutcome which is the same object returned from an RPC call.
 */
export class ExecutionResult extends RustRef {
  /**
   * Interpret the SuccessValue as a JSON value
   */
  unwrap_json_value<T>(): T {
    // check if is not Failure
    this.assert_success();
    // make sure it is SuccessValue
    if (this.has_value()) {
      return JSON.parse((this.status() as SuccessValue).value) as T;
    } else {
      throw new Error(
        `ExecutionStatus is a not a SuccessValue.\n${JSON.stringify(
          this.status()
        )}`
      );
    }
  }

  /**
   * Check if transaction was successful
   */
  is_ok(): boolean {
    return sim.$er$is_ok(this.ref);
  }

  /**
   * Test whether there is a SuccessValue
   */
  has_value(): boolean {
    return sim.$er$has_value(this.ref);
  }

  /**
   * Lookup an execution result from a hash
   */
  lookup_hash(hash: string): ExecutionResult | null {
    const res = sim.$er$lookup_hash(this.ref, hash);
    if (res.length == 0) {
      return null;
    } else {
      return new ExecutionResult(res[0]);
    }
  }

  /**
   * Returns the internal ExecutionOutcome
   */
  outcome(): ExecutionOutcome {
    const outcome = JSON.parse(sim.$er$outcome(this.ref));
    const raw_status = outcome.status;
    let status: ExecutionStatus;
    if (raw_status["SuccessValue"]) {
      status = {
        value: UTF8toStr(Uint8Array.from(raw_status["SuccessValue"])),
        type: "SuccessValue",
      };
    } else if (raw_status["Failure"]) {
      status = { error: raw_status["Failure"], type: "Failure" };
    } else if (raw_status["SuccessReceiptId"]) {
      status = {
        receipt: raw_status["SuccessReceiptId"],
        type: "SuccessReceiptId",
      };
    } else {
      throw new Error(
        `Failed to process outcome - ${JSON.stringify(raw_status)}`
      );
    }

    outcome["status"] = status;
    return outcome;
  }

  /**
   * Return results of promises from the `receipt_ids` in the ExecutionOutcome
   */
  get_receipt_results(): Array<ExecutionResult> {
    return sim
      .$er$get_receipt_results(this.ref)
      .map((r) => new ExecutionResult(r));
  }

  /**
   * Return the results of any promises created since the last transaction
   */
  promise_results(): Array<ExecutionResult> {
    return sim.$er$promise_results(this.ref).map((r) => new ExecutionResult(r));
  }

  promise_errors(): Array<ExecutionResult> {
    return sim.$er$promise_errors(this.ref).map((r) => new ExecutionResult(r));
  }

  /**
   * Execution status. Contains the result in case of successful execution.
   */
  status(): ExecutionStatus {
    return this.outcome().status;
  }

  /**
   * The amount of the gas burnt by the given transaction or receipt.
   */
  gas_burnt(): Gas {
    return sim.$er$gas_burnt(this.ref);
  }

  /**
   * The amount of tokens burnt corresponding to the burnt gas amount.
   * This value doesn't always equal to the `gas_burnt` multiplied by the gas price, because
   * the prepaid gas price might be lower than the actual gas price and it creates a deficit.
   */
  tokens_burnt(): Balance {
    return sim.$er$gas_burnt(this.ref);
  }

  /**
   * Logs from this transaction or receipt.
   */
  logs(): string[] {
    return sim.$er$logs(this.ref);
  }

  /**
   * The id of the account on which the execution happens. For transaction this is signer_id,
   * for receipt this is receiver_id.
   */
  executor_id(): AccountId {
    return sim.$er$executor_id(this.ref);
  }

  /**
   * Receipt IDs generated by this transaction or receipt.
   */
  receipt_ids(): CryptoHash[] {
    return sim.$er$receipt_ids(this.ref);
  }

  /**
   * Throw error if outcome is failure.
   */
  assert_success() {
    if (!this.is_ok()) {
      throw new Error(
        `ExecutionResult is a Failure.\n${JSON.stringify(this.outcome())}`
      );
    }
  }
}
