"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONBindingsBuilder = exports.isEntry = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const utils_1 = require("./utils");
const NEAR_DECORATOR = "nearBindgen";
function returnsVoid(node) {
    return utils_1.toString(node.signature.returnType) === "void";
}
function numOfParameters(node) {
    return node.signature.parameters.length;
}
function hasNearDecorator(stmt) {
    return ((isEntry(stmt) ||
        stmt.text.includes("@nearfile") ||
        stmt.statements.some((s) => s instanceof as_1.DeclarationStatement &&
            visitor_as_1.utils.hasDecorator(s, NEAR_DECORATOR))) &&
        !stmt.text.includes("@notNearfile"));
}
function isEntry(source) {
    return source.range.source.sourceKind == as_1.SourceKind.USER_ENTRY;
}
exports.isEntry = isEntry;
function isClass(type) {
    return type.kind == as_1.NodeKind.CLASSDECLARATION;
}
function isField(mem) {
    return mem.kind == as_1.NodeKind.FIELDDECLARATION;
}
function isStatic(mem) {
    return mem.is(as_1.CommonFlags.STATIC);
}
function isEncodable(mem) {
    return isField(mem) && !isStatic(mem);
}
function isPayable(func) {
    return (func.decorators != null &&
        func.decorators.some((s) => utils_1.toString(s.name) != "payable"));
}
function createDecodeStatements(_class) {
    return _class.members
        .filter(isEncodable)
        .map((field) => {
        const name = utils_1.toString(field.name);
        return (createDecodeStatement(field, `this.${name} = obj.has("${name}") ? `) +
            `: ${field.initializer != null
                ? utils_1.toString(field.initializer)
                : `this.${name}`};`);
    });
}
function createDecodeStatement(field, setterPrefix = "") {
    let T = utils_1.toString(field.type);
    let name = utils_1.toString(field.name);
    return `${setterPrefix}decode<${T}, JSON.Obj>(obj, "${name}")`;
}
function createEncodeStatements(_class) {
    return _class.members
        .filter(isEncodable)
        .map((field) => {
        let T = utils_1.toString(field.type);
        let name = utils_1.toString(field.name);
        return `encode<${T}, JSONEncoder>(this.${name}, "${name}", encoder);`;
    });
}
// TODO: Extract this into separate module, preferrable pluggable
class JSONBindingsBuilder extends visitor_as_1.BaseVisitor {
    constructor() {
        super(...arguments);
        this.sb = [];
        this.exportedClasses = new Map();
        this.wrappedFuncs = new Set();
    }
    static build(source) {
        return new JSONBindingsBuilder().build(source);
    }
    static nearFiles(sources) {
        return sources.filter(hasNearDecorator);
    }
    static checkTestBuild(sources) {
        this.isTest = sources.some((s) => s.normalizedPath.includes(".spec."));
    }
    visitClassDeclaration(node) {
        if (!this.exportedClasses.has(utils_1.toString(node.name))) {
            this.exportedClasses.set(utils_1.toString(node.name), node);
        }
        super.visitClassDeclaration(node);
    }
    needsWrapper(node) {
        let isExport = node.is(as_1.CommonFlags.EXPORT);
        let alreadyWrapped = this.wrappedFuncs.has(utils_1.toString(node.name));
        let noInputOrOutput = numOfParameters(node) == 0 && returnsVoid(node);
        if (!isExport ||
            alreadyWrapped ||
            noInputOrOutput ||
            JSONBindingsBuilder.isTest)
            return false;
        return isEntry(node) || visitor_as_1.utils.hasDecorator(node, NEAR_DECORATOR);
    }
    visitFunctionDeclaration(node) {
        if (!this.needsWrapper(node)) {
            super.visitFunctionDeclaration(node);
            return;
        }
        this.generateWrapperFunction(node);
        // Change function to not be an export
        node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
        this.wrappedFuncs.add(utils_1.toString(node.name));
        super.visit(node);
    }
    /*
    Create a wrapper function that will be export in the function's place.
    */
    generateWrapperFunction(func) {
        let signature = func.signature;
        let params = signature.parameters;
        let returnType = signature.returnType;
        let returnTypeName = utils_1.toString(returnType)
            .split("|")
            .map((name) => name.trim())
            .filter((name) => name !== "null")
            .join("|");
        let hasNull = utils_1.toString(returnType).includes("null");
        let name = func.name.text;
        if (func.decorators && func.decorators.length > 0) {
            this.sb.push(func.decorators.map((decorator) => utils_1.toString(decorator)).join("\n"));
        }
        this.sb.push(`function __wrapper_${name}(): void {`);
        if (params.length > 0) {
            this.sb.push(`  const obj = getInput();`);
        }
        if (utils_1.toString(returnType) !== "void") {
            this.sb.push(`  let result: ${utils_1.toString(returnType)} = ${name}(`);
        }
        else {
            this.sb.push(`  ${name}(`);
        }
        if (params.length > 0) {
            this.sb[this.sb.length - 1] += params
                .map((param) => {
                let name = utils_1.toString(param.name);
                let type = utils_1.toString(param.type);
                let res = `obj.has('${name}') ?
             ${createDecodeStatement(param)} : ${param.initializer
                    ? utils_1.toString(param.initializer)
                    : `requireParameter<${type}>("${name}")`}`;
                return res;
            })
                .join(",\n    ");
        }
        this.sb[this.sb.length - 1] += ");";
        if (utils_1.toString(returnType) !== "void") {
            this.sb.push(`  const val = encode<${returnTypeName}>(${hasNull ? `changetype<${returnTypeName}>(result)` : "result"});
  value_return(val.byteLength, val.dataStart);`);
        }
        this.sb.push(`}
export { __wrapper_${name} as ${name} }`);
    }
    typeName(type) {
        if (!isClass(type)) {
            return utils_1.toString(type);
        }
        type = type;
        let className = utils_1.toString(type.name);
        if (type.isGeneric) {
            className += "<" + type.typeParameters.map(utils_1.toString).join(", ") + ">";
        }
        return className;
    }
    build(source) {
        const isNearFile = source.text.includes("@nearfile");
        this.sb = [];
        this.visit(source);
        let sourceText = source.statements.map((stmt) => {
            let str;
            if (isClass(stmt) &&
                (visitor_as_1.utils.hasDecorator(stmt, NEAR_DECORATOR) ||
                    isNearFile)) {
                let _class = stmt;
                let fields = _class.members
                    .filter(isField)
                    .map((field) => field);
                if (fields.some((field) => field.type == null)) {
                    throw new Error("All Fields must have explicit type declaration.");
                }
                fields.forEach((field) => {
                    if (field.initializer == null) {
                        field.initializer = utils_1.SimpleParser.parseExpression(`defaultValue<${utils_1.toString(field.type)}>())`);
                    }
                });
                str = utils_1.toString(stmt);
                str = str.slice(0, str.lastIndexOf("}"));
                let className = this.typeName(_class);
                if (!visitor_as_1.utils.hasDecorator(stmt, NEAR_DECORATOR)) {
                    console.error("\x1b[31m", `@nearfile is deprecated use @${NEAR_DECORATOR} decorator on ${className}`, "\x1b[0m");
                }
                str += `
  decode<_V = Uint8Array>(buf: _V): ${className} {
    let json: JSON.Obj;
    if (buf instanceof Uint8Array) {
      json = JSON.parse(buf);
    } else {
      assert(buf instanceof JSON.Obj, "argument must be Uint8Array or Json Object");
      json = <JSON.Obj> buf;
    }
    return this._decode(json);
  }

  static decode(buf: Uint8Array): ${className} {
    return decode<${className}>(buf);
  }

  private _decode(obj: JSON.Obj): ${className} {
    ${createDecodeStatements(_class).join("\n    ")}
    return this;
  }

  _encode(name: string | null = "", _encoder: JSONEncoder | null = null): JSONEncoder {
    let encoder = _encoder == null ? new JSONEncoder() : _encoder;
    encoder.pushObject(name);
    ${createEncodeStatements(_class).join("\n    ")}
    encoder.popObject();
    return encoder;
  }
  encode(): Uint8Array {
    return this._encode().serialize();
  }

  serialize(): Uint8Array {
    return this.encode();
  }

  toJSON(): string {
    return this._encode().toString();
  }
}`;
            }
            else {
                str = utils_1.toString(stmt);
            }
            return str;
        });
        return sourceText.concat(this.sb).join("\n");
    }
}
exports.JSONBindingsBuilder = JSONBindingsBuilder;
JSONBindingsBuilder.isTest = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTkJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvSlNPTkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsc0NBWXVCO0FBQ3ZCLDJDQUFnRDtBQUNoRCxtQ0FBaUQ7QUFFakQsTUFBTSxjQUFjLEdBQUcsYUFBYSxDQUFDO0FBRXJDLFNBQVMsV0FBVyxDQUFDLElBQXlCO0lBQzVDLE9BQU8sZ0JBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxLQUFLLE1BQU0sQ0FBQztBQUN4RCxDQUFDO0FBRUQsU0FBUyxlQUFlLENBQUMsSUFBeUI7SUFDaEQsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUM7QUFDMUMsQ0FBQztBQUVELFNBQVMsZ0JBQWdCLENBQUMsSUFBWTtJQUNwQyxPQUFPLENBQ0wsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQy9CLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUNsQixDQUFDLENBQUMsRUFBRSxFQUFFLENBQ0osQ0FBQyxZQUFZLHlCQUFvQjtZQUNqQyxrQkFBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQ3hDLENBQUM7UUFDSixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUNwQyxDQUFDO0FBQ0osQ0FBQztBQUVELFNBQWdCLE9BQU8sQ0FBQyxNQUFxQjtJQUMzQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsSUFBSSxlQUFVLENBQUMsVUFBVSxDQUFDO0FBQ2pFLENBQUM7QUFGRCwwQkFFQztBQUVELFNBQVMsT0FBTyxDQUFDLElBQVU7SUFDekIsT0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJLGFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztBQUNo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Q0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDekMsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDdEMsSUFBSSxDQUFDLGtCQUFLLENBQUMsWUFBWSxDQUFtQixJQUFJLEVBQUUsY0FBYyxDQUFDLEVBQUU7b0JBQy9ELE9BQU8sQ0FBQyxLQUFLLENBQ1gsVUFBVSxFQUNWLGdDQUFnQyxjQUFjLGlCQUFpQixTQUFTLEVBQUUsRUFDMUUsU0FBUyxDQUNWLENBQUM7aUJBQ0g7Z0JBQ0QsR0FBRyxJQUFJO3NDQUN1QixTQUFTOzs7Ozs7Ozs7OztvQ0FXWCxTQUFTO29CQUN6QixTQUFTOzs7b0NBR08sU0FBUztNQUN2QyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDOzs7Ozs7O01BTzdDLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7Ozs7Ozs7Ozs7Ozs7OztFQWVqRCxDQUFDO2FBQ0k7aUJBQU07Z0JBQ0wsR0FBRyxHQUFHLGdCQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDdEI7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0MsQ0FBQzs7QUF2TUgsa0RBd01DO0FBck1RLDBCQUFNLEdBQUcsS0FBSyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgTm9kZSxcbiAgRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgTm9kZUtpbmQsXG4gIFNvdXJjZSxcbiAgU291cmNlS2luZCxcbiAgVHlwZU5vZGUsXG4gIENsYXNzRGVjbGFyYXRpb24sXG4gIERlY2xhcmF0aW9uU3RhdGVtZW50LFxuICBDb21tb25GbGFncyxcbiAgRmllbGREZWNsYXJhdGlvbixcbiAgUGFyYW1ldGVyTm9kZSxcbn0gZnJvbSBcInZpc2l0b3ItYXMvYXNcIjtcbmltcG9ydCB7IEJhc2VWaXNpdG9yLCB1dGlscyB9IGZyb20gXCJ2aXNpdG9yLWFzXCI7XG5pbXBvcnQgeyBTaW1wbGVQYXJzZXIsIHRvU3RyaW5nIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuY29uc3QgTkVBUl9ERUNPUkFUT1IgPSBcIm5lYXJCaW5kZ2VuXCI7XG5cbmZ1bmN0aW9uIHJldHVybnNWb2lkKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHRvU3RyaW5nKG5vZGUuc2lnbmF0dXJlLnJldHVyblR5cGUpID09PSBcInZvaWRcIjtcbn1cblxuZnVuY3Rpb24gbnVtT2ZQYXJhbWV0ZXJzKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBudW1iZXIge1xuICByZXR1cm4gbm9kZS5zaWduYXR1cmUucGFyYW1ldGVycy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGhhc05lYXJEZWNvcmF0b3Ioc3RtdDogU291cmNlKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgKGlzRW50cnkoc3RtdCkgfHxcbiAgICAgIHN0bXQudGV4dC5pbmNsdWRlcyhcIkBuZWFyZmlsZVwiKSB8fFxuICAgICAgc3RtdC5zdGF0ZW1lbnRzLnNvbWUoXG4gICAgICAgIChzKSA9PlxuICAgICAgICAgIHMgaW5zdGFuY2VvZiBEZWNsYXJhdGlvblN0YXRlbWVudCAmJlxuICAgICAgICAgIHV0aWxzLmhhc0RlY29yYXRvcihzLCBORUFSX0RFQ09SQVRPUilcbiAgICAgICkpICYmXG4gICAgIXN0bXQudGV4dC5pbmNsdWRlcyhcIkBub3ROZWFyZmlsZVwiKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbnRyeShzb3VyY2U6IFNvdXJjZSB8IE5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHNvdXJjZS5yYW5nZS5zb3VyY2Uuc291cmNlS2luZCA9PSBTb3VyY2VLaW5kLlVTRVJfRU5UUlk7XG59XG5cbmZ1bmN0aW9uIGlzQ2xhc3ModHlwZTogTm9kZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZS5raW5kID09IE5vZGVLaW5kLkNMQVNTREVDTEFSQVRJT047XG59XG5cbmZ1bmN0aW9uIGlzRmllbGQobWVtOiBEZWNsYXJhdGlvblN0YXRlbWVudCkge1xuICByZXR1cm4gbWVtLmtpbmQgPT0gTm9kZUtpbmQuRklFTERERUNMQVJBVElPTjtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMobWVtOiBEZWNsYXJhdGlvblN0YXRlbWVudCkge1xuICByZXR1cm4gbWVtLmlzKENvbW1vbkZsYWdzLlNUQVRJQyk7XG59XG5cbmZ1bmN0aW9uIGlzRW5jb2RhYmxlKG1lbTogRGVjbGFyYXRpb25TdGF0ZW1lbnQpIHtcbiAgcmV0dXJuIGlzRmllbGQobWVtKSAmJiAhaXNTdGF0aWMobWVtKTtcbn1cblxuZnVuY3Rpb24gaXNQYXlhYmxlKGZ1bmM6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBmdW5jLmRlY29yYXRvcnMgIT0gbnVsbCAmJlxuICAgIGZ1bmMuZGVjb3JhdG9ycy5zb21lKChzKSA9PiB0b1N0cmluZyhzLm5hbWUpICE9IFwicGF5YWJsZVwiKVxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNvZGVTdGF0ZW1lbnRzKF9jbGFzczogQ2xhc3NEZWNsYXJhdGlvbik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIF9jbGFzcy5tZW1iZXJzXG4gICAgLmZpbHRlcihpc0VuY29kYWJsZSlcbiAgICAubWFwKChmaWVsZDogRmllbGREZWNsYXJhdGlvbik6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gdG9TdHJpbmcoZmllbGQubmFtZSk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjcmVhdGVEZWNvZGVTdGF0ZW1lbnQoZmllbGQsIGB0aGlzLiR7bmFtZX0gPSBvYmouaGFzKFwiJHtuYW1lfVwiKSA/IGApICtcbiAgICAgICAgYDogJHtcbiAgICAgICAgICBmaWVsZC5pbml0aWFsaXplciAhPSBudWxsXG4gICAgICAgICAgICA/IHRvU3RyaW5nKGZpZWxkLmluaXRpYWxpemVyKVxuICAgICAgICAgICAgOiBgdGhpcy4ke25hbWV9YFxuICAgICAgICB9O2BcbiAgICAgICk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY29kZVN0YXRlbWVudChcbiAgZmllbGQ6IEZpZWxkRGVjbGFyYXRpb24gfCBQYXJhbWV0ZXJOb2RlLFxuICBzZXR0ZXJQcmVmaXggPSBcIlwiXG4pOiBzdHJpbmcge1xuICBsZXQgVCA9IHRvU3RyaW5nKGZpZWxkLnR5cGUhKTtcbiAgbGV0IG5hbWUgPSB0b1N0cmluZyhmaWVsZC5uYW1lKTtcbiAgcmV0dXJuIGAke3NldHRlclByZWZpeH1kZWNvZGU8JHtUfSwgSlNPTi5PYmo+KG9iaiwgXCIke25hbWV9XCIpYDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW5jb2RlU3RhdGVtZW50cyhfY2xhc3M6IENsYXNzRGVjbGFyYXRpb24pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBfY2xhc3MubWVtYmVyc1xuICAgIC5maWx0ZXIoaXNFbmNvZGFibGUpXG4gICAgLm1hcCgoZmllbGQ6IEZpZWxkRGVjbGFyYXRpb24pOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IFQgPSB0b1N0cmluZyhmaWVsZC50eXBlISk7XG4gICAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKGZpZWxkLm5hbWUpO1xuICAgICAgcmV0dXJuIGBlbmNvZGU8JHtUfSwgSlNPTkVuY29kZXI+KHRoaXMuJHtuYW1lfSwgXCIke25hbWV9XCIsIGVuY29kZXIpO2A7XG4gICAgfSk7XG59XG5cbi8vIFRPRE86IEV4dHJhY3QgdGhpcyBpbnRvIHNlcGFyYXRlIG1vZHVsZSwgcHJlZmVycmFibGUgcGx1Z2dhYmxlXG5leHBvcnQgY2xhc3MgSlNPTkJpbmRpbmdzQnVpbGRlciBleHRlbmRzIEJhc2VWaXNpdG9yIHtcbiAgcHJpdmF0ZSBzYjogc3RyaW5nW10gPSBbXTtcbiAgcHJpdmF0ZSBleHBvcnRlZENsYXNzZXM6IE1hcDxzdHJpbmcsIENsYXNzRGVjbGFyYXRpb24+ID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgaXNUZXN0ID0gZmFsc2U7XG4gIHdyYXBwZWRGdW5jczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG5cbiAgc3RhdGljIGJ1aWxkKHNvdXJjZTogU291cmNlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbmV3IEpTT05CaW5kaW5nc0J1aWxkZXIoKS5idWlsZChzb3VyY2UpO1xuICB9XG5cbiAgc3RhdGljIG5lYXJGaWxlcyhzb3VyY2VzOiBTb3VyY2VbXSk6IFNvdXJjZVtdIHtcbiAgICByZXR1cm4gc291cmNlcy5maWx0ZXIoaGFzTmVhckRlY29yYXRvcik7XG4gIH1cblxuICBzdGF0aWMgY2hlY2tUZXN0QnVpbGQoc291cmNlczogU291cmNlW10pIHtcbiAgICB0aGlzLmlzVGVzdCA9IHNvdXJjZXMuc29tZSgocykgPT4gcy5ub3JtYWxpemVkUGF0aC5pbmNsdWRlcyhcIi5zcGVjLlwiKSk7XG4gIH1cblxuICB2aXNpdENsYXNzRGVjbGFyYXRpb24obm9kZTogQ2xhc3NEZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIGlmICghdGhpcy5leHBvcnRlZENsYXNzZXMuaGFzKHRvU3RyaW5nKG5vZGUubmFtZSkpKSB7XG4gICAgICB0aGlzLmV4cG9ydGVkQ2xhc3Nlcy5zZXQodG9TdHJpbmcobm9kZS5uYW1lKSwgbm9kZSk7XG4gICAgfVxuICAgIHN1cGVyLnZpc2l0Q2xhc3NEZWNsYXJhdGlvbihub2RlKTtcbiAgfVxuXG4gIG5lZWRzV3JhcHBlcihub2RlOiBGdW5jdGlvbkRlY2xhcmF0aW9uKTogYm9vbGVhbiB7XG4gICAgbGV0IGlzRXhwb3J0ID0gbm9kZS5pcyhDb21tb25GbGFncy5FWFBPUlQpO1xuICAgIGxldCBhbHJlYWR5V3JhcHBlZCA9IHRoaXMud3JhcHBlZEZ1bmNzLmhhcyh0b1N0cmluZyhub2RlLm5hbWUpKTtcbiAgICBsZXQgbm9JbnB1dE9yT3V0cHV0ID0gbnVtT2ZQYXJhbWV0ZXJzKG5vZGUpID09IDAgJiYgcmV0dXJuc1ZvaWQobm9kZSk7XG4gICAgaWYgKFxuICAgICAgIWlzRXhwb3J0IHx8XG4gICAgICBhbHJlYWR5V3JhcHBlZCB8fFxuICAgICAgbm9JbnB1dE9yT3V0cHV0IHx8XG4gICAgICBKU09OQmluZGluZ3NCdWlsZGVyLmlzVGVzdFxuICAgIClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaXNFbnRyeShub2RlKSB8fCB1dGlscy5oYXNEZWNvcmF0b3Iobm9kZSwgTkVBUl9ERUNPUkFUT1IpO1xuICB9XG5cbiAgdmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubmVlZHNXcmFwcGVyKG5vZGUpKSB7XG4gICAgICBzdXBlci52aXNpdEZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2VuZXJhdGVXcmFwcGVyRnVuY3Rpb24obm9kZSk7XG4gICAgLy8gQ2hhbmdlIGZ1bmN0aW9uIHRvIG5vdCBiZSBhbiBleHBvcnRcbiAgICBub2RlLmZsYWdzID0gbm9kZS5mbGFncyBeIENvbW1vbkZsYWdzLkVYUE9SVDtcbiAgICB0aGlzLndyYXBwZWRGdW5jcy5hZGQodG9TdHJpbmcobm9kZS5uYW1lKSk7XG4gICAgc3VwZXIudmlzaXQobm9kZSk7XG4gIH1cblxuICAvKlxuICBDcmVhdGUgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleHBvcnQgaW4gdGhlIGZ1bmN0aW9uJ3MgcGxhY2UuXG4gICovXG4gIHByaXZhdGUgZ2VuZXJhdGVXcmFwcGVyRnVuY3Rpb24oZnVuYzogRnVuY3Rpb25EZWNsYXJhdGlvbikge1xuICAgIGxldCBzaWduYXR1cmUgPSBmdW5jLnNpZ25hdHVyZTtcbiAgICBsZXQgcGFyYW1zID0gc2lnbmF0dXJlLnBhcmFtZXRlcnM7XG4gICAgbGV0IHJldHVyblR5cGUgPSBzaWduYXR1cmUucmV0dXJuVHlwZTtcbiAgICBsZXQgcmV0dXJuVHlwZU5hbWUgPSB0b1N0cmluZyhyZXR1cm5UeXBlKVxuICAgICAgLnNwbGl0KFwifFwiKVxuICAgICAgLm1hcCgobmFtZSkgPT4gbmFtZS50cmltKCkpXG4gICAgICAuZmlsdGVyKChuYW1lKSA9PiBuYW1lICE9PSBcIm51bGxcIilcbiAgICAgIC5qb2luKFwifFwiKTtcbiAgICBsZXQgaGFzTnVsbCA9IHRvU3RyaW5nKHJldHVyblR5cGUpLmluY2x1ZGVzKFwibnVsbFwiKTtcbiAgICBsZXQgbmFtZSA9IGZ1bmMubmFtZS50ZXh0O1xuICAgIGlmIChmdW5jLmRlY29yYXRvcnMgJiYgZnVuYy5kZWNvcmF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2IucHVzaChcbiAgICAgICAgZnVuYy5kZWNvcmF0b3JzLm1hcCgoZGVjb3JhdG9yKSA9PiB0b1N0cmluZyhkZWNvcmF0b3IpKS5qb2luKFwiXFxuXCIpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnNiLnB1c2goYGZ1bmN0aW9uIF9fd3JhcHBlcl8ke25hbWV9KCk6IHZvaWQge2ApO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zYi5wdXNoKGAgIGNvbnN0IG9iaiA9IGdldElucHV0KCk7YCk7XG4gICAgfVxuICAgIGlmICh0b1N0cmluZyhyZXR1cm5UeXBlKSAhPT0gXCJ2b2lkXCIpIHtcbiAgICAgIHRoaXMuc2IucHVzaChgICBsZXQgcmVzdWx0OiAke3RvU3RyaW5nKHJldHVyblR5cGUpfSA9ICR7bmFtZX0oYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2IucHVzaChgICAke25hbWV9KGApO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2JbdGhpcy5zYi5sZW5ndGggLSAxXSArPSBwYXJhbXNcbiAgICAgICAgLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKHBhcmFtLm5hbWUpO1xuICAgICAgICAgIGxldCB0eXBlID0gdG9TdHJpbmcocGFyYW0udHlwZSk7XG4gICAgICAgICAgbGV0IHJlcyA9IGBvYmouaGFzKCcke25hbWV9JykgP1xuICAgICAgICAgICAgICR7Y3JlYXRlRGVjb2RlU3RhdGVtZW50KHBhcmFtKX0gOiAke1xuICAgICAgICAgICAgcGFyYW0uaW5pdGlhbGl6ZXJcbiAgICAgICAgICAgICAgPyB0b1N0cmluZyhwYXJhbS5pbml0aWFsaXplcilcbiAgICAgICAgICAgICAgOiBgcmVxdWlyZVBhcmFtZXRlcjwke3R5cGV9PihcIiR7bmFtZX1cIilgXG59YDtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIixcXG4gICAgXCIpO1xuICAgIH1cbiAgICB0aGlzLnNiW3RoaXMuc2IubGVuZ3RoIC0gMV0gKz0gXCIpO1wiO1xuICAgIGlmICh0b1N0cmluZyhyZXR1cm5UeXBlKSAhPT0gXCJ2b2lkXCIpIHtcbiAgICAgIHRoaXMuc2IucHVzaChgICBjb25zdCB2YWwgPSBlbmNvZGU8JHtyZXR1cm5UeXBlTmFtZX0+KCR7XG4gICAgICAgIGhhc051bGwgPyBgY2hhbmdldHlwZTwke3JldHVyblR5cGVOYW1lfT4ocmVzdWx0KWAgOiBcInJlc3VsdFwiXG4gICAgICB9KTtcbiAgdmFsdWVfcmV0dXJuKHZhbC5ieXRlTGVuZ3RoLCB2YWwuZGF0YVN0YXJ0KTtgKTtcbiAgICB9XG4gICAgdGhpcy5zYi5wdXNoKGB9XG5leHBvcnQgeyBfX3dyYXBwZXJfJHtuYW1lfSBhcyAke25hbWV9IH1gKTtcbiAgfVxuXG4gIHByaXZhdGUgdHlwZU5hbWUodHlwZTogVHlwZU5vZGUgfCBDbGFzc0RlY2xhcmF0aW9uKTogc3RyaW5nIHtcbiAgICBpZiAoIWlzQ2xhc3ModHlwZSkpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh0eXBlKTtcbiAgICB9XG4gICAgdHlwZSA9IDxDbGFzc0RlY2xhcmF0aW9uPnR5cGU7XG4gICAgbGV0IGNsYXNzTmFtZSA9IHRvU3RyaW5nKHR5cGUubmFtZSk7XG4gICAgaWYgKHR5cGUuaXNHZW5lcmljKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCI8XCIgKyB0eXBlLnR5cGVQYXJhbWV0ZXJzIS5tYXAodG9TdHJpbmcpLmpvaW4oXCIsIFwiKSArIFwiPlwiO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG5cbiAgYnVpbGQoc291cmNlOiBTb3VyY2UpOiBzdHJpbmcge1xuICAgIGNvbnN0IGlzTmVhckZpbGUgPSBzb3VyY2UudGV4dC5pbmNsdWRlcyhcIkBuZWFyZmlsZVwiKTtcbiAgICB0aGlzLnNiID0gW107XG4gICAgdGhpcy52aXNpdChzb3VyY2UpO1xuXG4gICAgbGV0IHNvdXJjZVRleHQgPSBzb3VyY2Uuc3RhdGVtZW50cy5tYXAoKHN0bXQpID0+IHtcbiAgICAgIGxldCBzdHI7XG4gICAgICBpZiAoXG4gICAgICAgIGlzQ2xhc3Moc3RtdCkgJiZcbiAgICAgICAgKHV0aWxzLmhhc0RlY29yYXRvcig8Q2xhc3NEZWNsYXJhdGlvbj5zdG10LCBORUFSX0RFQ09SQVRPUikgfHxcbiAgICAgICAgICBpc05lYXJGaWxlKVxuICAgICAgKSB7XG4gICAgICAgIGxldCBfY2xhc3MgPSA8Q2xhc3NEZWNsYXJhdGlvbj5zdG10O1xuICAgICAgICBsZXQgZmllbGRzID0gX2NsYXNzLm1lbWJlcnNcbiAgICAgICAgICAuZmlsdGVyKGlzRmllbGQpXG4gICAgICAgICAgLm1hcCgoZmllbGQ6IEZpZWxkRGVjbGFyYXRpb24pID0+IGZpZWxkKTtcbiAgICAgICAgaWYgKGZpZWxkcy5zb21lKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PSBudWxsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFsbCBGaWVsZHMgbXVzdCBoYXZlIGV4cGxpY2l0IHR5cGUgZGVjbGFyYXRpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgIGlmIChmaWVsZC5pbml0aWFsaXplciA9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWVsZC5pbml0aWFsaXplciA9IFNpbXBsZVBhcnNlci5wYXJzZUV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIGBkZWZhdWx0VmFsdWU8JHt0b1N0cmluZyhmaWVsZC50eXBlISl9PigpKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RtdCk7XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBzdHIubGFzdEluZGV4T2YoXCJ9XCIpKTtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMudHlwZU5hbWUoX2NsYXNzKTtcbiAgICAgICAgaWYgKCF1dGlscy5oYXNEZWNvcmF0b3IoPENsYXNzRGVjbGFyYXRpb24+c3RtdCwgTkVBUl9ERUNPUkFUT1IpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiXFx4MWJbMzFtXCIsXG4gICAgICAgICAgICBgQG5lYXJmaWxlIGlzIGRlcHJlY2F0ZWQgdXNlIEAke05FQVJfREVDT1JBVE9SfSBkZWNvcmF0b3Igb24gJHtjbGFzc05hbWV9YCxcbiAgICAgICAgICAgIFwiXFx4MWJbMG1cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IGBcbiAgZGVjb2RlPF9WID0gVWludDhBcnJheT4oYnVmOiBfVik6ICR7Y2xhc3NOYW1lfSB7XG4gICAgbGV0IGpzb246IEpTT04uT2JqO1xuICAgIGlmIChidWYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBqc29uID0gSlNPTi5wYXJzZShidWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoYnVmIGluc3RhbmNlb2YgSlNPTi5PYmosIFwiYXJndW1lbnQgbXVzdCBiZSBVaW50OEFycmF5IG9yIEpzb24gT2JqZWN0XCIpO1xuICAgICAganNvbiA9IDxKU09OLk9iaj4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGpzb24pO1xuICB9XG5cbiAgc3RhdGljIGRlY29kZShidWY6IFVpbnQ4QXJyYXkpOiAke2NsYXNzTmFtZX0ge1xuICAgIHJldHVybiBkZWNvZGU8JHtjbGFzc05hbWV9PihidWYpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGVjb2RlKG9iajogSlNPTi5PYmopOiAke2NsYXNzTmFtZX0ge1xuICAgICR7Y3JlYXRlRGVjb2RlU3RhdGVtZW50cyhfY2xhc3MpLmpvaW4oXCJcXG4gICAgXCIpfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2VuY29kZShuYW1lOiBzdHJpbmcgfCBudWxsID0gXCJcIiwgX2VuY29kZXI6IEpTT05FbmNvZGVyIHwgbnVsbCA9IG51bGwpOiBKU09ORW5jb2RlciB7XG4gICAgbGV0IGVuY29kZXIgPSBfZW5jb2RlciA9PSBudWxsID8gbmV3IEpTT05FbmNvZGVyKCkgOiBfZW5jb2RlcjtcbiAgICBlbmNvZGVyLnB1c2hPYmplY3QobmFtZSk7XG4gICAgJHtjcmVhdGVFbmNvZGVTdGF0ZW1lbnRzKF9jbGFzcykuam9pbihcIlxcbiAgICBcIil9XG4gICAgZW5jb2Rlci5wb3BPYmplY3QoKTtcbiAgICByZXR1cm4gZW5jb2RlcjtcbiAgfVxuICBlbmNvZGUoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZSgpLnNlcmlhbGl6ZSgpO1xuICB9XG5cbiAgc2VyaWFsaXplKCk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZSgpO1xuICB9XG5cbiAgdG9KU09OKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZSgpLnRvU3RyaW5nKCk7XG4gIH1cbn1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RtdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0pO1xuICAgIHJldHVybiBzb3VyY2VUZXh0LmNvbmNhdCh0aGlzLnNiKS5qb2luKFwiXFxuXCIpO1xuICB9XG59XG4iXX0=